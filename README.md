# AccessiBot

AI-powered web accessibility analysis with intelligent caching, dynamic batch processing, webhook CI/CD integration, and optional GitHub PR automation — built on Encore.ts with a modern React frontend.

## Key Features

- Automated accessibility analysis for HTML content (URL or raw HTML)
- AI-enhanced code fixes (OpenAI) with robust DB-backed caching and demo mode
- Dynamic, priority-aware batch processing with adaptive sizing and rate-limiting
- Webhook ingestion (GitHub + generic) driving async analysis via Pub/Sub
- GitHub integration for automated PR creation with fixed content (demo-safe)
- Scheduled cache cleanup via Cron jobs (daily + weekly deep clean)
- Real-time analytics and monitoring dashboard (delivery, trends, performance)
- Friendly UI (React, Tailwind v4, shadcn/ui, TanStack Query, lucide-react)

## Project Structure

- backend/
  - accessibot/
    - encore.service.ts
    - analyze.ts
    - ai-service.ts
    - cache.ts
    - cache-migrations/
      - 1_create_cache_table.up.sql
    - rate-limiter.ts
    - rate-limiter-migrations/
      - 1_create_rate_limiter_table.up.sql
    - webhook.ts
    - webhook-processor.ts
    - webhook-status.ts
    - webhook-analytics.ts
    - webhook-docs.ts
    - webhook-migrations/
      - 1_create_webhook_analysis_table.up.sql
    - github.ts
    - cleanup.ts
    - cron-cleanup.ts
    - demo.ts
- frontend/
  - App.tsx
  - components/
    - AccessibilityAnalyzer.tsx
    - CacheStatus.tsx
    - GitHubIntegration.tsx
    - WebhookStatus.tsx
    - WebhookAnalyticsDashboard.tsx
    - GlowCard.tsx
    - demo.tsx
    - ui/
      - squares-background.tsx
      - glowing-effect.tsx
      - fluid-blob.tsx

Notes:
- All backend code is implemented using Encore.ts under backend/.
- Frontend uses React + Vite + Tailwind v4 + shadcn/ui. Entry is frontend/App.tsx.
- Some framework scaffolding files (e.g., main.tsx, index.html, index.css) are auto-generated by the platform.

## Backend Overview (Encore.ts)

Service: accessibot

- Databases
  - ai-cache: Stores AI-generated fix snippets (ai_fixes table)
  - rate-limiter: Persists request timestamps for sliding-window rate limiting
  - webhook-analysis: Tracks webhook analyses and outcomes (webhook_analyses table)

- Pub/Sub
  - Topic: accessibility-analysis (at-least-once delivery)
  - Subscription: process-accessibility-analysis

- Cron Jobs
  - daily-cache-cleanup (2:00 AM UTC) → standard cleanup
  - weekly-cache-cleanup (Sunday 1:00 AM UTC) → deep cleanup

- Secrets (configured via Infrastructure tab)
  - OpenAIKey: optional; enables AI fixes; when missing, demo suggestions are used
  - GitHubToken: optional; enables real PR creation; when missing, PR flow is simulated
  - WebhookSecret: optional; GitHub signature verification; if missing, validation is bypassed (demo-friendly)

### Demo Mode Behavior

- AI: If OpenAIKey is not provided, AI responses are replaced with mock suggestions and results are still cached.
- GitHub: If GitHubToken is not provided, repository list and PR creation are simulated.

## API Endpoints

All endpoints live under the accessibot service.

Public (expose: true) endpoints:

- Analyze and AI status
  - POST /analyze
    - Body: { url?: string; html?: string }
    - Returns: { issues: AccessibilityIssue[]; summary: { total, high, medium, low } }
  - GET /batch-processor/status
    - Returns current batch stats and priority queue summary
  - GET /demo-mode
    - Returns flags for demo mode (AI/GitHub)

- Cache management and stats
  - POST /cleanup/cache
    - Body: { intervalDays?: number }
    - Triggers cache cleanup (custom interval or default)
  - GET /cache/stats
    - Returns cache statistics and current config

- Webhooks
  - POST /webhook/github
    - Expects GitHub push payload
    - Headers: X-Hub-Signature-256, X-GitHub-Event, X-GitHub-Delivery
    - Validates signature if WebhookSecret is configured
    - Publishes AccessibilityAnalysisRequest to topic
  - POST /webhook/generic
    - Generic provider push-like payload (repository + commits)
    - Publishes AccessibilityAnalysisRequest to topic
  - GET /webhook/docs
    - Returns webhook documentation, examples, and setup steps

- Webhook analyses (status & analytics)
  - GET /webhook/analyses
    - Query: page, limit, status, repository
    - Returns paginated analysis results
  - GET /webhook/analyses/:webhookId
    - Returns a single analysis by webhook ID
  - GET /webhook/stats
    - Aggregate counts, PR created, averages, last analysis
  - POST /webhook/analyses/:webhookId/retry
    - Resets failed analysis to pending (demo-only requeue semantics)
  - GET /webhook/analytics
    - Query: startDate, endDate, repository
    - Returns delivery analytics, repo stats, issue trends, fix analytics, processing times
  - GET /webhook/performance
    - Real-time metrics snapshot (current hour, last 24h, today’s success rate, etc.)

- GitHub integration
  - GET /github/repositories
    - Lists repositories for authenticated user (or mock list in demo)
  - POST /github/pull-request
    - Body: { repoOwner, repoName, fixes: [{ fileName, content, issues[] }], title?, description? }
    - Creates a PR on a new branch with provided content (simulated in demo)

## AI, Caching, and Rate Limiting

- AI Service
  - Uses @ai-sdk/openai (generateText) when OpenAIKey is available
  - Batch processing with dynamic batch size and delay to target response time and limit error rates
  - Priority queuing (high/medium/low severity → higher priority)
  - Fallback to individual requests on batch failure
  - Robust parsing and error handling for AI responses

- Cache
  - DB table: ai_fixes(issue_hash, fixed_code_snippet, created_at)
  - Hashing strategy: deterministic hash over issue type/element/description
  - TTL-based lookup; configurable defaults in cache.ts
  - Endpoints and cron jobs support cleanup and visibility into cache state

- Rate Limiter
  - Sliding window using DB table rate_limit_requests
  - Default: 50 requests/hour for OpenAI usage
  - Prevents exceeding configured budget; exposes reset and remaining

## Webhook Processing Pipeline

1. Webhook received (GitHub or generic) and validated (if WebhookSecret set)
2. Changed files filtered to likely HTML/UI sources
3. AccessibilityAnalysisRequest published to topic
4. Subscription handler:
   - Persists initial analysis record (processing)
   - Generates demo HTML (for demo purposes) and runs analyzeHTML
   - Optional AI enhancement of issues
   - Optionally creates a PR when high-severity issues exist
   - Updates analysis record (completed/failed) with counts and PR URL

Note: In this demo, file contents are simulated. Integrating real repository file fetch is an extension point.

## Frontend

- AccessibilityAnalyzer
  - URL/HTML analysis
  - Displays issues and AI-enhanced fixes
  - GitHub PR creation UI
  - Cache status and batch processor stats

- WebhookStatus
  - Overview metrics, recent analyses with filters and retry
  - Analytics dashboard with trends, repository performance, processing times
  - Docs and setup guidance for webhooks

- UI/UX
  - Tailwind v4 and shadcn/ui for components
  - Animated backgrounds (squares), glowing accent effects
  - Responsive design, subtle animations, dark-friendly color tokens

## Configuration

Configure secrets in the Infrastructure tab:

- OpenAIKey
  - Enables AI-enhanced fixes; otherwise demo suggestions are used
- GitHubToken
  - Enables real repository listing and PR creation; otherwise simulated
- WebhookSecret
  - Enables GitHub webhook signature validation (X-Hub-Signature-256)

If secrets are not set, the system gracefully falls back to demo mode.

## Extensibility Notes

- Real repository file fetching in webhook-processor.ts can be added using provider APIs
- Authentication is intentionally omitted; add it only if needed
- Additional issue detectors can be added to analyzeHTML
- AI prompt construction/parsing logic is modularized for batch/individual flows

## Limitations

- Webhook processor uses sample HTML (demo) instead of live repo content
- No authentication by default (by design)
- AI output is best-effort; always validate changes before merging

## Types and Contracts

The backend uses native TypeScript interfaces for request/response schemas, ensuring type safety in the frontend via ~backend imports. Examples:

- AccessibilityIssue (analyze.ts)
- BatchProcessorInfo (batch-stats.ts)
- WebhookAnalysisResult (webhook-processor.ts)
- GitHubRepo, CreatePullRequestRequest/Response (github.ts)
- Webhook payload contracts (webhook.ts)

## Safety and Security

- GitHub webhook signature validation (HMAC-SHA256) when WebhookSecret is configured
- Robust API error handling via Encore.ts APIError
- No secrets in code; all secrets managed through the platform’s Infrastructure tab

